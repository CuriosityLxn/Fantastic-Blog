## 浏览器的多进程架构

Chrome浏览器使用多个进程来隔离不同的网页，打开一个 tab 页相当于起了一个进程。

##### 为什么 Chrome 使用多进程架构

把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战。因为如果浏览器中的一个 tab 页崩了，将会导致其他被打开的网页应用。

**常用进程：**

- Browser Process：主线程，负责协调、主控
    - 地址栏、书签栏、前进后退按钮
    - 管理各个 tab 页，创建、销毁其他进程
    - 不可见的底层操作：网络请求、文件访问等
- Renderer Process：渲染进程，也叫渲染引擎、浏览器内核
    - 事件处理、执行脚本、页面渲染
- GPU Process：负责处理 GPU 相关的任务
- Plugin Process：管理网页用到的插件，每个插件对应一个进程

##### 为什么不使用多线程

同一进程下的线程共享内存空间和资源，**线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题**。
进程间不共享内存，不会有太多安全问题。

### 浏览器内核

也被称为**渲染引擎**，通过获取页面内容（DOM）、整理信息（应用 CSS）、计算、组合，最终输出可视化图像结果。

Chrome 为每个 tab 启用单独的进程，所以每个 tab 都是其渲染引擎的实体。这些渲染引擎相互独立。

#### 浏览器内核是多线程的

在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

- GUI 渲染引擎线程
- JavaScript 引擎线程
- 定时触发器线程
- 事件触发线程
- 异步 HTTP 请求线程

**GUI 渲染线程和JavaScript 引擎线程互斥！！！**

#### GUI 渲染线程

负责渲染浏览器界面的 HTML 元素，重绘（Repaint）和回流（Reflow）在该线程执行。

JavaScript 引擎线程运行脚本期间，GUI 渲染线程挂起，被“冻结”。

#### JavaScript 引擎线程

也称 JS 内核，例如 V8 引擎，负责解析、运行 Javascript 脚本的虚拟机。

JS 引擎基于**事件驱动**和**单线程**执行的，等待事件队列中的任务进来，然后处理。

这个唯一的 JS 线程也被称为主线程。

##### 为什么 JS 是单线程的？

JS 会操作 DOM 树和 CSSOM 树来呈现动态交互和依赖服务器逻辑的交互，多线程同时处理同一个 DOM 节点，浏览器无法决定使用哪一个线程的处理结果，也无法决定处理的先后顺序，所以用单线程来避免。

JS 线程和 GUI 线程互斥也是因为如此，而且渲染线程可能会获取前后不一致的数据。

所以当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

如果 JS 执行事件过长，会导致页面渲染不连贯，也就是 **JS 阻塞了页面加载**。

#### 定时触发器线程

负责处理定时事件。

单线程处理任何事件都有可能发生阻塞，如果处于阻塞线程状态就会影响记计时的准确，所以计时器最好不存在在其他线程中，单独启用线程以确保计时的准确性。

#### 事件触发线程

当浏览器触发事件时，事件触发线程会将其放在事件队列末尾，等待 JS 引擎空闲时处理。

这些事件可以是
- JS 引擎正在执行的代码中的定时任务
- 其他线程的事件：浏览器 DOM 事件，AJAX 请求等

#### 异步 HTTP 请求线程

负责处理 HTTP 请求。

浏览器单独启用一个线程用于检测 XMLHttpRequest 连接后的状态变更。设有回调函数时，异步 HTTP 请求线程就将产生状态变更的事件放到JS引擎的处理事件队列中等待处理。

### 同步、异步和定时器执行

##### 同步任务的执行

在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。这些任务存放在执行栈中。

- 输入输出
- 变量声明、函数初始化、事件绑定
- 同步函数：函数返回时可立即拿到结果。

##### 异步任务的执行

未进入主线程，而是进入 FIFO 的任务队列排队执行。
异步任务准备好后触发某些事件通知主线程，并将回调函数返回给主线程。

###### 宏任务

- I/O
- 定时任务：setTimeout、setInterval、setImmediate（only node）
- requestAnimationFrame（only browser）
- 响应 DOM 操作而触发的任务：onClick、onScroll……
- UI 渲染
- 部分 Events Dispatching：在某些特定的EventTarget对象上分派事件对象

###### 微任务
- Promise.then catch finally
- await 后面的代码
- fs.readFile
- http.get
- process.nextTick（only node）
- MutationObserver（only browser）

##### 同步、异步执行优先级

执行栈中的任务执行完，先读取执行完微任务，再执行宏任务。

##### 定时器执行
定时器执行是异步执行的。

```js
setTimeout(fn, 500) 
```

**定时器线程**在 500ms 后将签名函数 fn 放在事件队列末尾，**js 线程**空闲后轮询执行事件队列。

> HTML5 标准规定了setTimeout()的第二个参数的最小值，即最短间隔，不得低于4毫秒。如果低于这个值，就会自动增加。
> 
> 在此之前，老版本的浏览器都将最短间隔设为10毫秒。

##### setTimeout 和 setInterval 的区别

setTimeout 只会执行一次。
setInterval 每隔一段时间就执行一次。
这里的“执行”是指，任务被定时器线程定时投放进事件队列中，排队等待 JS 线程空闲后执行.只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行。可能会被高耗时任务阻塞，不能保证时间间隔到后立马执行。

##### 更精确的定时执行：window.requestAnimationFrame()

requestAnimationFrame 和计时器的区别：
[详情](https://flaviocopes.com/requestanimationframe/)

requestAnimationFrame 的 callback 在**浏览器 UI 线程**的队列中，由**系统决定**回调函数执行时机。跟随显示器刷新频率，精确；tab 页非激活状态不执行，节省 CPU 资源。



### 事件循环（Event Loop）

主线程将执行栈中的同步任务执行完毕后，执行栈空了，主线程从事件队列中读取新的压入执行栈并执行。若事件队列中没有任务则等待，直至有新任务。

这个过程是不断循环的，被称为事件循环。

> 事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。 -- nodejs

> An event loop has one or more task queues. A task queue is a **set** of tasks.
> 一次事件循环中有一个或多个（宏）任务队列。一个任务队列是许多任务的集合。
>
> Task queues are sets, not queues, because step one of the event loop processing model grabs the first runnable task from the chosen queue, instead of dequeuing the first task.
> **任务队列的数据结构是集合，不是队列**，因为事件循环执行模型操作的第一步是从选择的队列中获取第一个可执行的任务，而不是让排在队列首位的任务脱离队列（出栈）。-- 规范







