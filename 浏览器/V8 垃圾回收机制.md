## 内存的生命周期

申请内存 --> 使用内存（读写）--> 释放或归还内存。

Chrome 单 tab 页内存上限：32位系统为 512M，64位系统为 1.4G。

由[《V8 引擎中的内存分配》](https://github.com/CuriosityLxn/Fantastic-Blog/blob/main/JS%20%E5%9F%BA%E7%A1%80/V8%20%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.md)已知 JS 的数据存储在栈内存或堆内存，以下分别概述两种类型内存的垃圾处理方式。

## 栈内存的垃圾回收：ESP 下移

> ESP(Extended Stack Pointer) 扩展站指针寄存器，用于存放栈顶指针。

执行 JS 时，将上下文（主要指函数）压进栈中，ESP上移，始终指向栈顶。函数执行完之后，ESP下移，该函数上下文出栈销毁。

## 堆内存垃圾回收：分代收集
分代收集基于代际假说，代际假说认为，大部分新对象的生存时间会短于老对象，通常可在一次垃圾回收周期内被清理。
这里的“新、老”是指声明、赋值对象的时间。

于是 V8 将堆内存分为新生代和老生代，新生代内存又分为两个区：from 和 to。

新对象存放在 from 中，经过一次垃圾回收后还存活的，按顺序复制到 to 中**连续的**存储空间，并将 from 和 to 空间互换。
再经过一次垃圾回收仍存活的，被移动到老生代。

垃圾回收流程：

1. 标记内存中的活动对象（正在使用）和非活动对象（未被使用）。
2. 删除非活动对象，释放内存空间。
3. 整理内存空间，避免频繁回收后产生大量内存碎片（不连续内存空间）。

整个回收流程由主、副垃圾回收器完成。

#### 主垃圾回收器
负责基本任务：

- 标记：标记对象是否能被访问。从一个根对象开始递归遍历，能被访问到的对象标记为活动对象，否则被标记为非活动对象，需要被回收。
- 清除：主垃圾回收器负责维护一个 freeList 列表，将非活动对象的内存地址添加进去，有新对象申请内存时，freeList 若有空间合适的内存块时，会优先从这里分配内存给新对象。
- 整理（可选）：将活动对象复制到相同空间的连续内存中。

#### 副垃圾回收器
负责新生代垃圾回收。

- 标记：同上。
- 复制：将 from 空间中的活动对象复制到 to 中，更新引用地址并做标记，若下一次垃圾回收后仍为活动对象，则会根据这个标记被复制到老生代区域。
- 交换：复制完成后，交换 from、to 的空间。


#### 其他常提到的堆内存垃圾回收机制：

- 标记清除：只有标记和删除步骤，没有整理，会因为没有连续内存而分配失败。
- 引用计数：实时统计指向堆内存的引用数量，引用数为 0 时，立即回收内存。优点：效率高、性能高、回收及时。缺点：存在循环引用是，引用数不会降到 0，内存永远不会被回收。
- 复制算法（新生代）：没有清除阶段的开销，能在较短时间完成，避免内存碎片的产生。缺点：复制需要时间成本，数量大则耗时久；可用内存空间减少了一半。
- 标记-压缩算法（老生代）：将活动对象移到内存的一端，集中在一起，直接清理掉边界以外的内存，释放连续空间。缺点：清除、整理操作很麻烦，需要对整个堆做多次搜索，堆越大耗时越长。

## 垃圾回收提效

#### 垃圾回收的执行时机
垃圾回收运行在主线程，会阻塞其他任务的执行，这被称作全停顿。
当垃圾回收需要运行比较长时间时，JS 脚本不再执行，也无法执行动画、响应用户交互，造成丢帧卡顿。

#### 提效方案

- 增量标记 + 惰性清理：把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。
- 并行回收：多开几个辅助线程，执行垃圾回收。



