浏览器本地存储包括三部分：
- cookie：保持登录态，跟踪用户行为
- Web Storage：localStorage、sessionStorage
- Indexed：是一个运行在浏览器上的事务数据库系统，没有存储上限，甚至可以保存二进制数据。

它们都遵循浏览器同源策略，跨域不能访问，此外：  
sessionStorage 哪怕是同一个域名的不同页面都不能共享。  
cookie 是在指定的域名及子域名下可以共享。  

## localStorage、sessionStorage 和 cookie 有什么区别？ 
![pic](https://user-images.githubusercontent.com/31687804/175782495-21904cb5-5048-465a-8f06-46f23e3b6be7.png)

## 浏览器缓存
- Service Worker：运行在浏览器背后的独立线程，传输协议必须用 HTTPS。
- Memory Cache
- Disk Cache
- Push Cache

**Service Worker： **
Service Worker 涉及到请求拦截，必须使用 HTTPS 协议来保障安全。
与其他三种浏览器内建的缓存机制不同，使用 Service Worker 可以自由控制缓存**哪些文件、如何匹配缓存、如何读取缓存，并且缓存是可持续性的**。
实现缓存功能的三个步骤： 
1. 注册 Service Worker 
2. 监听到 install 事件
3. 缓存文件
下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就调用 fetch 请求数据。
如果我们没有在 Service Worker 命中缓存的话，会根据内建缓存优先级去查找是否有缓存。但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

**Memory Cache： 内存中的缓存**
主要包含：页面中已抓取到的资源，比如已下载的字体、脚本、图片等。
预加载的资源也存放在这里，就是 <link rel="prefetch | preload">相关指令。
读取速度比磁盘快，缓存持续性短，一旦关闭 Tab 页面，内存中的缓存也就被释放了。
内存容量比硬盘小的多，不能用于存放大量数据。
需要注意的事情是，内存缓存在缓存资源时，不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

**Disk Cache： 硬盘中的缓存**
读取速度慢，比内存缓存胜在容量和存储实效性上。
可缓存的内容覆盖面最广，根据 HTTP header 中的字段判断哪些资源需要缓存，哪些资源不请求可以直接使用，哪些资源已过期需要重新请求。
在跨域情况下，相同地址的资源一旦被硬盘缓存，就不会再次去请求数据。

**浏览器如何选择内存存储和硬盘存储： **
说法不一，
- 对于大文件，大概率存硬盘
- 系统内存使用率高时，优先存硬盘

Push Cache：推送缓存 / HTTP 2.0
当以上三种缓存都没有被命中时，才会使用到。
它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 
不常见，不做详细介绍。

 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。
 大部分的接口都会通过配置 HTTP Header 的一些字段，命中浏览器缓存，达到更好的性能。

## 浏览器的缓存策略：强缓存和协商缓存
- 强缓存：在过期时间到来之前，不请求服务器资源，直接使用内存缓存的资源。 
- 协商缓存：询问服务器是否有资源更新。无更新返回 304，浏览器使用内存缓存的资源渲染；有更新返回 200，使用服务器返回的内容渲染。 

**如何选择**
- 强缓存：不经常更新的静态资源。
- 协商缓存：更新频繁的资源。
两种缓存可以同时存在，**优先级：强缓存 > 协商缓存**。若命中强缓存，则不再进行缓存协商。

**设置强缓存**
Expires(HTTP1.0)：
Exprires的值为服务端返回的数据到期时间。现在大多数使用 Cache-Control 替代。
缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。

Pragma(HTTP1.0)：
HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存。
**优先级：Pragma > Expires**，如果同时定义了 Expires 过期时间和 Pragma: no-cache，Pragma 生效。服务端响应添加 Pragma: no-cache，浏览器表现行为和刷新(F5)类似。

Cache-Control(HTTP1.1)：
- private：仅客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在t秒后失效
- no-cache：需要使用协商缓存来验证缓存数据
- no-store：所有内容都不会缓存

**优先级：Cache-Control: max-age=t > Expires=T**。
命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码；Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。

设置协商缓存 
Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。
If-Modified-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 If-Modified-Since，则与被请求资源的最后修改时间进行对比资源是否被修改：
- 有修改：传输响应一个整体，服务器返回：200 OK
- 无修改：只传输响应头，服务器返回：304 Not Modified，浏览器从缓存中获取信息。
If-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。
- 有修改：则开始`继续'传送文件，服务器返回: 200 OK
- 无修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)
 这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

Etag(HTTP1.1)：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识，生成规则由服务器决定。
If-Match：条件请求，携带上一次请求中资源的Etag，服务器根据这个字段判断文件是否有新的修改。
If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到此报文后发现If-None-Match则与Etag进行对比：
- 不同，说明资源有修改，则响应整个资源内容，返回状态码200；
- 相同，说明资源无修改，则响应header，返回状态码304，浏览器直接从缓存中获取数据信息。

但是实际应用中很少使用 Etag 了，因为计算 Etag的会占用服务器计算的资源。
- F5 跳过强缓存，检查协商缓存（发送一个请求带上If-Modify-since）
- Ctrl+F5 强制刷新网页，你删除缓存中的资源，直接从服务器加载，跳过强缓存和协商缓存。

**强缓存和协商缓存的异同：** 
- 相同：命中缓存时，服务器不会返回资源。
- 不同：强缓存不对服务器发送请求，但协商缓存会。当协商缓存也没命中时，服务器就会将资源发送回客户端。



