## 数据类型

- **基本数据类型**：String，Boolean，Number，Null，Undefined，Symbol，BigInt

- **引用数据类型**：Object，Array，Function，以及各种继承于 Object 的其他类型

## 内存特点

栈内存：

1. 存储的值不能变
2. 存储空间小
3. 可以直接操作变量，运行快
4. 系统自动分配等长的存储空间（32/64 位），线性有序

堆内存：

1. 存储的值可变
2. 存储空间大
3. 需要通过引用地址读取内存，不能直接操作，运行效率低
4. 通过代码分配空间，零散无序

## 存储方式
ECMAScript规范中没有区分栈内存和堆内存，没有明确说明每种类型的数据存储在哪种内存，没有明确定义 String 类型如何实现，具体内存分配要看各个 JS 引擎如何实现。所以对类型存储是有争议的，通常认为：
- **基本数据类型**：真实值直接存储在栈(stack)内存中，除了闭包中的变量。
- **引用数据类型**：真实值存在堆(heap)内存，栈(stack)中存储真实值在堆内存中的地址。

闭包中的变量保存在堆内存中。

又有人分析了 [V8 引擎中字符串的 5 种表达模式](https://segmentfault.com/a/1190000023258026)，表示：
- **Boolean、Null、Undefined、Number 保存在栈内存**中，这些类型的值都可以用32位的数据来表示
- **Symbol、BigInt、Object、String 保存在堆中，栈里面只会保存这些值的地址的引用**。

在 V8 引擎中，如果两个变量被赋值了同一字符串

```js
var a = 'string';
var b = 'string';
```
则，a、b 保存在栈内存中，且他们保存了相同的堆内存地址，这种现象叫做字符串驻留（String interning）。好处是
- 节省内存，相同的内容只分配了一块内存
- 在全等比较（===）时运行快

## 赋值

假如有两个变量 a、b，a 在初始化时赋值，现在另 b = a，

若 a 的真实值存在**栈内存**中，则将 b push 进栈内存，并将 a 的真实值复制到 b 分配到位置上，

<table>
  <tr><th>赋值前的栈内存</th><th>赋值后的栈内存</th></tr>
  <tr><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f91 | a | 6|

  </td><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f92  | b | 6|
  | 10000f91 | a | 6|

  </td></tr>
</table>

若 a 的真实值存在**堆内存**中，则将 b push 进栈内存，并将 a 的引用地址复制到 b 分配到位置上，
<table>
  <tr>赋值前的内存分配</tr>
  <tr><th>栈内存 </th><th>堆内存</th></tr>
  <tr><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f91 | a | 40000f33|

  </td><td>

  | 地址 | 值  |
  | --- | --- |
  |    |    | 
  | 40000f31  |  |
  | 40000f32  |  |
  | 40000f33  |  {n: 1} |
  | 40000f34  |  |

  </td></tr>
</table>

<table>
  <tr>赋值后的内存分配</tr>
  <tr><th>栈内存 </th><th>堆内存</th></tr>
  <tr><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f92  | b | 40000f33|
  | 10000f91 | a | 40000f33|

  </td><td>

  | 地址 | 值  |
  | --- | --- |
  |    |    | 
  | 40000f31  |  |
  | 40000f32  |  |
  | 40000f33  |  {n: 1} |
  | 40000f34  |  |

  </td></tr>
</table>

#### 实参、形参赋值

ES 中所有的函数参数都是按值传递。就是说，实参、形参赋值之间的赋值和上面的 '=' 赋值是一样的：

- 实参的值在栈内存时，形参在栈内存的值直接从实参的栈内存拷贝
- 实参的值在堆内存时，形参在栈内存的值拷贝的是实参在栈内存中保存的堆内存地址

例如，

```js
function setName(obj) {
  obj.name = 'David';
}

var person = new Object();
setName(person);
console.log(person.name); // 'David'
```
<table>
  <tr><th>栈内存 </th><th>堆内存</th></tr>
  <tr><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f92 | obj | 40000f33|
  | 10000f91 | person | 40000f33|

  </td><td>

  | 地址 | 值  |
  | --- | --- |
  |    |    | 
  | 40000f31  |  |
  | 40000f32  |  |
  | 40000f33  | {name: 'David'} |
  | 40000f34  |  |

  </td></tr>
</table>

```js
function setName(obj) {
  obj.name = 'David';
  obj = new Object();
  obj.name = 'Becca';
}

var person = new Object();
setName(person);
console.log(person.name); // 'David'
```

<table>
  <tr><th>栈内存 </th><th>堆内存</th></tr>
  <tr><td>

  | 指针地址 | 指针名称|指针的值  |
  | --- | --- | --- |
  |    |    |    |
  | 10000f92 | obj | 40000f31|
  | 10000f91 | person | 40000f33|

  </td><td>

  | 地址 | 值  |
  | --- | --- |
  |    |    | 
  | 40000f31  | {name: 'Becca'} |
  | 40000f32  |  |
  | 40000f33  | {name: 'David'} |
  | 40000f34  |  |

  </td></tr>
</table>

关于函数调用过程中的内存分配，掘金大佬在[《我不知道的JS之JavaScript内存模型 - v8 是怎么通过栈来管理函数调用的？》](https://juejin.cn/post/6844904200002863118)这个模块讲的比较好

#### 后话

V8 也对 Number 进行了引擎层面（JS 不区分的！！）的优化，按照长度分为 Smi 和 HeapNumber，

- Smi：32位以内的小整数，放在栈内存，操作快，比如 for 循环
- HeapNumber：长于32位的浮点数，放在堆内存，比如 NaN,Infinity


#### 参考资料

- 《深入理解 JavaScript》2016年8月第3版（好古早）
- 《JavaScript 高级程序设计（第三版）》 第4章《变量、作用域和内存问题》 2012年3月第1版 （比上一本更古早）
- [《我不知道的JS之JavaScript内存模型》](https://juejin.cn/post/6844904200002863118)
- [JavaScript中栈，执行栈及栈帧的区别](https://juejin.cn/post/6844904192637665288)，看他文字，图画的不咋地
